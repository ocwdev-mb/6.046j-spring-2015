---
content_type: page
description: This section provides insights and information about the course from
  the instructors.
draft: false
layout: instructor_insights
learning_resource_types: []
ocw_type: ThisCourseAtMITSection
title: Instructor Insights
uid: 55d505b1-69f7-f01b-fee9-cba048f3cd8f
---
## Course Overview

This page focuses on the course *6.046 Design and Analysis of Algorithms* as taught by Professors Erik Demaine, Srini Devadas, and Nancy Lynch in Spring 2015.

This course is an intermediate class covering the design of computer algorithms and the analysis of sophisticated algorithms. Students learn how to analyze the asymptotic performance of algorithms, and gain familiarity with major algorithms and data structures. They also apply important algorithmic design paradigms and methods of analysis, in addition to synthesizing efficient algorithms in common engineering design situations. Course materials are designed to help students understand the difference between tractable and intractable problems and to become familiar with strategies to deal with intractability. Students attend lectures and recitation sessions, and complete 10 problem sets throughout the semester.

## Curriculum Information

### Prerequisites

- [*6.006 Introduction to Algorithms*](/courses/6-006-introduction-to-algorithms-fall-2011)
- Either [*6.042J Mathematics for Computer Science*](/courses/6-042j-mathematics-for-computer-science-fall-2010) or [*18.310 Principles of Discrete Applied Mathematics*](/courses/18-310-principles-of-discrete-applied-mathematics-fall-2013)

### Requirements Satisfied

6.046 can be applied toward a [Bachelor of Science in Computer Science and Engineering](http://catalog.mit.edu/degree-charts/computer-science-engineering-course-6-3/).

### Offered

Every fall and spring semester

{{< anchor "insights" >}}{{< /anchor >}}

## Meet the Educator

{{< resource 2bb373d5-5379-9f63-e629-ff8d265a988e >}}

Erik Demaine, Professor in the Department of Electrical Engineering & Computer Science

*In the following video, Erik Domaine discusses his role in the course, his interest in algorithms, and how teaching* 6.046 Design and Analysis of Algorithms *helps him understand algorithms at a deeper level.*

- {{% resource_link 8b81015e-ad3a-9fdf-d3a6-7d185b09b87e "Meet the Educator" %}} 

{{< anchor "insights" >}}{{< /anchor >}}

## Instructor Insights

{{< quote "This is me living the dream, teaching the topic I love." "—Erik Demaine" >}}

*In the following videos, Professor Erik Demaine describes various aspects of how he teaches* 6.046 Design and Analysis of Algorithms.

- {{% resource_link 6d1731c9-5f41-d5c8-03df-ac5d90e5d19d "On Teaching Complex Content" %}}
- {{% resource_link 9842f082-4f07-40ce-72ec-128200613f32 "On the Challenge of Assessing Students’ Abilities to Apply Algorithms in New and Creative Ways" %}}
- {{% resource_link 4a7ae1be-6940-4ffe-cb6c-bffd28ed0892 "Engaging Learners" %}}
- {{% resource_link 3650f5a8-b4ae-a4c4-447a-ef41fea86a9d "Co-Teaching the Course" %}}

{{< anchor "assessment" >}}{{< /anchor >}}

## Assessment

The students' grades were based on the following activities:

- 30% Problem sets
- 20% Quiz 1 (2 hours)
- 20% Quiz 2 (2 hours)
- 30% Final exam (3 hours)

### Instructor Insights on Assessment

Professor Erik Demaine shares his insights about assessment in his video, “{{% resource_link 9842f082-4f07-40ce-72ec-128200613f32 "On the Challenge of Assessing Students’ Abilities to Apply Algorithms in New and Creative Ways" %}}.”

## Student Information

### Enrollment

About 250 students

### Breakdown by Year

Mostly juniors and seniors

### Breakdown by Major

Mostly computer science majors

### Typical Student Background

Students tends to be interested in exploring algorithms at a more sophisticated level than what is typically offered in introductory level courses.

## Course Outcomes

### Course Goals for Students

Students who complete this course will have demonstrated the ability to do the following:

- Argue the correctness of algorithms using inductive proofs and loop invariants.
- Analyze worst-case running times of algorithms using asymptotic analysis. Compare the asymptotic behaviors of functions obtained by elementary compositions of polynomials, exponentials, and logarithmic functions. Describe the relative merits of worst-, average-, and best-case analysis.
- Analyze average-case running times of algorithms whose running time is probabilistic. Employ indicator random variables and linearity of expectation to perform the analyses. Recite analyses of algorithms that employ this method of analysis.
- Explain the basic properties of randomized algorithms and methods for analyzing them. Recite algorithms that employ randomization. Explain the difference between a randomized algorithm and an algorithm with probabilistic inputs.
- Describe the divide-and conquer paradigm and explain when an algorithm design situation calls for it. Recite algorithms that employ this paradigm. Synthesize divide-and-conquer algorithms. Derive and solve recurrences describing the performance of divide-and-conquer algorithms.
- Describe the dynamic-programming paradigm and explain when an algorithmic design situation calls for it. Recite algorithms that employ this paradigm. Synthesize dynamic programming algorithms, and analyze them.
- Describe the greedy paradigm and explain when an algorithm design situation calls for it. Recite algorithms that employ this paradigm. Synthesize greedy algorithms, and analyze them.
- Explain the major graph algorithms and their analyses. Employ graphs to model engineering problems, when appropriate. Synthesize new graph algorithms and algorithms that employ graph computations as key components, and analyze them.
- Describe a linear program and cite problems that can be solved using linear programming. Reduce problems to linear programming formulations. Understand the complexity of various linear programming approaches.
- Explain basic complexity classes such as P, NP, and NP-complete, and be able to use analysis and reduction techniques to show membership or non-membership of a problem in these classes.
- Describe approaches to speeding up algorithms by making use of distributed and/or parallel computation.
- Explain the concept and basic examples of basing cryptographic security on hard computational problems.
- Understand and explain approaches to dealing with problems that are NP-complete such as the design of heuristic, approximation, or fixed-parameter algorithms.